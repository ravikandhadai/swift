// RUN: %target-sil-opt -enable-sil-verify-all %s -predictable-deadalloc-elim | %FileCheck %s

sil_stage canonical

import Swift
import Builtin

//////////////////
// Declarations //
//////////////////

class Klass {}
struct KlassWithKlassTuple {
  var first: Klass
  var second: (Klass, Klass)
  var third: Klass
}

///////////
// Tests //
///////////

// CHECK-LABEL: sil [ossa] @simple_trivial_stack : $@convention(thin) (Builtin.Int32) -> () {
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'simple_trivial_stack'
sil [ossa] @simple_trivial_stack : $@convention(thin) (Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32):
  %1 = alloc_stack $Builtin.Int32
  store %0 to [trivial] %1 : $*Builtin.Int32
  dealloc_stack %1 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_trivial_init_box : $@convention(thin) (Builtin.Int32) -> () {
// CHECK-NOT: alloc_box
// CHECK: } // end sil function 'simple_trivial_init_box'
sil [ossa] @simple_trivial_init_box : $@convention(thin) (Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32):
  %1 = alloc_box ${ var Builtin.Int32 }
  %2 = project_box %1 : ${ var Builtin.Int32 }, 0
  store %0 to [trivial] %2 : $*Builtin.Int32
  destroy_value %1 : ${ var Builtin.Int32 }
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_trivial_uninit_box : $@convention(thin) (Builtin.Int32) -> () {
// CHECK-NOT: alloc_box
// CHECK: } // end sil function 'simple_trivial_uninit_box'
sil [ossa] @simple_trivial_uninit_box : $@convention(thin) (Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32):
  %1 = alloc_box ${ var Builtin.Int32 }
  %2 = project_box %1 : ${ var Builtin.Int32 }, 0
  store %0 to [trivial] %2 : $*Builtin.Int32
  dealloc_box %1 : ${ var Builtin.Int32 }
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_nontrivial_stack : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] :
// CHECK-NEXT: destroy_value [[ARG]]
// CHECK-NEXT: tuple
// CHECK-NEXT: return
// CHECK: } // end sil function 'simple_nontrivial_stack'
sil [ossa] @simple_nontrivial_stack : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject):
  %1 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %1 : $*Builtin.NativeObject
  destroy_addr %1 : $*Builtin.NativeObject
  dealloc_stack %1 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_nontrivial_init_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK-NOT: alloc_box
// CHECK: } // end sil function 'simple_nontrivial_init_box'
sil [ossa] @simple_nontrivial_init_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject):
  %1 = alloc_box ${ var Builtin.NativeObject }
  %2 = project_box %1 : ${ var Builtin.NativeObject }, 0
  store %0 to [init] %2 : $*Builtin.NativeObject
  destroy_value %1 : ${ var Builtin.NativeObject }
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_nontrivial_uninit_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] :
// CHECK-NEXT: destroy_value [[ARG]]
// CHECK-NEXT: tuple
// CHECK-NEXT: return
// CHECK: } // end sil function 'simple_nontrivial_uninit_box'
sil [ossa] @simple_nontrivial_uninit_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject):
  %1 = alloc_box ${ var Builtin.NativeObject }
  %2 = project_box %1 : ${ var Builtin.NativeObject }, 0
  store %0 to [init] %2 : $*Builtin.NativeObject
  destroy_addr %2 : $*Builtin.NativeObject
  dealloc_box %1 : ${ var Builtin.NativeObject }
  %9999 = tuple()
  return %9999 : $()
}

//////////////////
// Assign Tests //
//////////////////

// Make sure that we do eliminate this allocation
// CHECK-LABEL: sil [ossa] @simple_assign_take_trivial : $@convention(thin) (Builtin.Int32, @in Builtin.Int32) -> () {
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'simple_assign_take_trivial'
sil [ossa] @simple_assign_take_trivial : $@convention(thin) (Builtin.Int32, @in Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32, %1 : $*Builtin.Int32):
  %2 = alloc_stack $Builtin.Int32
  store %0 to [trivial] %2 : $*Builtin.Int32
  copy_addr [take] %1 to %2 : $*Builtin.Int32
  dealloc_stack %2 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_init_copy : $@convention(thin) (@owned Builtin.NativeObject, @in_guaranteed Builtin.NativeObject) -> () {
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'simple_init_copy'
sil [ossa] @simple_init_copy : $@convention(thin) (@owned Builtin.NativeObject, @in_guaranteed Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject, %1 : $*Builtin.NativeObject):
  %2 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %2 : $*Builtin.NativeObject
  destroy_addr %2 : $*Builtin.NativeObject
  copy_addr %1 to [initialization] %2 : $*Builtin.NativeObject
  destroy_addr %2 : $*Builtin.NativeObject
  dealloc_stack %2 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// This we can promote successfully.
// CHECK-LABEL: sil [ossa] @simple_init_take : $@convention(thin) (@owned Builtin.NativeObject, @in Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG0:%.*]] : @owned $Builtin.NativeObject, [[ARG1:%.*]] : $*Builtin.NativeObject):
// CHECK-NOT: alloc_stack
// CHECK:  destroy_value [[ARG0]]
// CHECK:  destroy_addr [[ARG1]]
// CHECK: } // end sil function 'simple_init_take'
sil [ossa] @simple_init_take : $@convention(thin) (@owned Builtin.NativeObject, @in Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject, %1 : $*Builtin.NativeObject):
  %2 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %2 : $*Builtin.NativeObject
  destroy_addr %2 : $*Builtin.NativeObject
  copy_addr [take] %1 to [initialization] %2 : $*Builtin.NativeObject
  destroy_addr %2 : $*Builtin.NativeObject
  dealloc_stack %2 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// Since we are copying the input argument, we can not get rid of the copy_addr,
// meaning we shouldn't eliminate the allocation here.
// CHECK-LABEL: sil [ossa] @simple_assign_no_take : $@convention(thin) (@owned Builtin.NativeObject, @in_guaranteed Builtin.NativeObject) -> () {
// CHECK: alloc_stack
// CHECK: copy_addr
// CHECK: } // end sil function 'simple_assign_no_take'
sil [ossa] @simple_assign_no_take : $@convention(thin) (@owned Builtin.NativeObject, @in_guaranteed Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject, %1 : $*Builtin.NativeObject):
  %2 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %2 : $*Builtin.NativeObject
  copy_addr %1 to %2 : $*Builtin.NativeObject
  destroy_addr %2 : $*Builtin.NativeObject
  dealloc_stack %2 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// If PMO understood how to promote assigns, we should be able to handle this
// case.
// CHECK-LABEL: sil [ossa] @simple_assign_take : $@convention(thin) (@owned Builtin.NativeObject, @in Builtin.NativeObject) -> () {
// CHECK: alloc_stack
// CHECK: copy_addr
// CHECK: } // end sil function 'simple_assign_take'
sil [ossa] @simple_assign_take : $@convention(thin) (@owned Builtin.NativeObject, @in Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject, %1 : $*Builtin.NativeObject):
  %2 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %2 : $*Builtin.NativeObject
  copy_addr [take] %1 to %2 : $*Builtin.NativeObject
  destroy_addr %2 : $*Builtin.NativeObject
  dealloc_stack %2 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_diamond_without_assign : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] :
// CHECK-NOT: alloc_stack
// CHECK-NOT: store
// CHECK: destroy_value [[ARG]]
// CHECK: } // end sil function 'simple_diamond_without_assign'
sil [ossa] @simple_diamond_without_assign : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject):
  %1 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %1 : $*Builtin.NativeObject
  cond_br undef, bb1, bb2

bb1:
  br bb3

bb2:
  br bb3

bb3:
  destroy_addr %1 : $*Builtin.NativeObject
  dealloc_stack %1 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// We should not promote this due to this being an assign to %2.
// CHECK-LABEL: sil [ossa] @simple_diamond_with_assign : $@convention(thin) (@owned Builtin.NativeObject, @in Builtin.NativeObject) -> () {
// CHECK: alloc_stack
// CHECK: copy_addr
// CHECK: } // end sil function 'simple_diamond_with_assign'
sil [ossa] @simple_diamond_with_assign : $@convention(thin) (@owned Builtin.NativeObject, @in Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject, %1 : $*Builtin.NativeObject):
  %2 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %2 : $*Builtin.NativeObject
  cond_br undef, bb1, bb2

bb1:
  copy_addr [take] %1 to %2 : $*Builtin.NativeObject
  br bb3

bb2:
  destroy_addr %1 : $*Builtin.NativeObject
  br bb3

bb3:
  destroy_addr %2 : $*Builtin.NativeObject
  dealloc_stack %2 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @simple_diamond_with_assign_remove : $@convention(thin) (@owned Builtin.NativeObject, @in Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG0:%.*]] : @owned $Builtin.NativeObject, [[ARG1:%.*]] : $*Builtin.NativeObject):
// CHECK-NOT: alloc_stack
// CHECK: bb1:
// CHECK: destroy_addr [[ARG1]]
// CHECK-NOT: copy_addr
// CHECK: bb2:
// CHECK: } // end sil function 'simple_diamond_with_assign_remove'
sil [ossa] @simple_diamond_with_assign_remove : $@convention(thin) (@owned Builtin.NativeObject, @in Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject, %1 : $*Builtin.NativeObject):
  %2 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %2 : $*Builtin.NativeObject
  cond_br undef, bb1, bb2

bb1:
  destroy_addr %2 : $*Builtin.NativeObject
  copy_addr [take] %1 to [initialization] %2 : $*Builtin.NativeObject
  br bb3

bb2:
  destroy_addr %1 : $*Builtin.NativeObject
  br bb3

bb3:
  destroy_addr %2 : $*Builtin.NativeObject
  dealloc_stack %2 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// Make sure that we can handle structs, tuples.
// CHECK-LABEL: sil [ossa] @multiple_inits_1 : $@convention(thin) (@owned Klass, @owned Klass, @owned Klass, @owned Klass) -> () {
// CHECK: bb0([[ARG0:%.*]] : @owned $Klass, [[ARG1:%.*]] : @owned $Klass, [[ARG2:%.*]] : @owned $Klass, [[ARG3:%.*]] : @owned $Klass):
// CHECK: destroy_value [[ARG0]]
// CHECK: destroy_value [[ARG1]]
// CHECK: destroy_value [[ARG2]]
// CHECK: destroy_value [[ARG3]]
// CHECK: } // end sil function 'multiple_inits_1'
sil [ossa] @multiple_inits_1 : $@convention(thin) (@owned Klass, @owned Klass, @owned Klass, @owned Klass) -> () {
bb0(%0 : @owned $Klass, %1 : @owned $Klass, %2 : @owned $Klass, %3 : @owned $Klass):
  %stack = alloc_stack $KlassWithKlassTuple
  %stack0 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.first
  %stack1 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.second
  %stack10 = tuple_element_addr %stack1 : $*(Klass, Klass), 0
  %stack11 = tuple_element_addr %stack1 : $*(Klass, Klass), 1
  %stack2 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.third

  store %0 to [init] %stack0 : $*Klass
  store %1 to [init] %stack10 : $*Klass
  store %2 to [init] %stack11 : $*Klass
  store %3 to [init] %stack2 : $*Klass

  destroy_addr %stack : $*KlassWithKlassTuple
  dealloc_stack %stack : $*KlassWithKlassTuple
  %9999 = tuple()
  return %9999 : $()
}

// Make sure that we can handle structs, tuples that are not fully available
// themselves, but whose components are fully available.
// CHECK-LABEL: sil [ossa] @multiple_inits_with_load_1 : $@convention(thin) (@owned Klass, @owned Klass, @owned Klass, @owned Klass) -> () {
// CHECK: bb0([[ARG0:%.*]] : @owned $Klass, [[ARG1:%.*]] : @owned $Klass, [[ARG2:%.*]] : @owned $Klass, [[ARG3:%.*]] : @owned $Klass):
// CHECK:   [[TUP:%.*]] = tuple ([[ARG1]] : $Klass, [[ARG2]] : $Klass)
// CHECK:   [[STRUCT:%.*]] = struct $KlassWithKlassTuple ([[ARG0]] : $Klass, [[TUP]] : $(Klass, Klass), [[ARG3]] : $Klass)
// CHECK:   destroy_value [[STRUCT]]
// CHECK: } // end sil function 'multiple_inits_with_load_1'
sil [ossa] @multiple_inits_with_load_1 : $@convention(thin) (@owned Klass, @owned Klass, @owned Klass, @owned Klass) -> () {
bb0(%0 : @owned $Klass, %1 : @owned $Klass, %2 : @owned $Klass, %3 : @owned $Klass):
  %stack = alloc_stack $KlassWithKlassTuple
  %stack0 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.first
  %stack1 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.second
  %stack10 = tuple_element_addr %stack1 : $*(Klass, Klass), 0
  %stack11 = tuple_element_addr %stack1 : $*(Klass, Klass), 1
  %stack2 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.third

  store %0 to [init] %stack0 : $*Klass
  store %1 to [init] %stack10 : $*Klass
  store %2 to [init] %stack11 : $*Klass
  %c = copy_value %3 : $Klass
  store %c to [init] %stack2 : $*Klass

  %loaded = load [take] %stack2 : $*Klass
  destroy_value %loaded : $Klass

  store %3 to [init] %stack2 : $*Klass
  destroy_addr %stack : $*KlassWithKlassTuple
  dealloc_stack %stack : $*KlassWithKlassTuple
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @multiple_inits_2 : $@convention(thin) (@owned Klass, @owned (Klass, Klass), @owned Klass) -> () {
// CHECK: bb0([[ARG0:%.*]] : @owned $Klass, [[ARG1:%.*]] : @owned $(Klass, Klass), [[ARG2:%.*]] : @owned $Klass):
// CHECK:  destroy_value [[ARG0]]
// CHECK:  destroy_value [[ARG1]]
// CHECK:  destroy_value [[ARG2]]
// CHECK: } // end sil function 'multiple_inits_2'
sil [ossa] @multiple_inits_2 : $@convention(thin) (@owned Klass, @owned (Klass, Klass), @owned Klass) -> () {
bb0(%0 : @owned $Klass, %1 : @owned $(Klass, Klass), %2 : @owned $Klass):
  %stack = alloc_stack $KlassWithKlassTuple
  %stack0 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.first
  %stack1 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.second
  %stack2 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.third

  store %0 to [init] %stack0 : $*Klass
  store %1 to [init] %stack1 : $*(Klass, Klass)
  store %2 to [init] %stack2 : $*Klass

  destroy_addr %stack : $*KlassWithKlassTuple
  dealloc_stack %stack : $*KlassWithKlassTuple
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @multiple_inits_with_load_2 : $@convention(thin) (@owned Klass, @owned (Klass, Klass), @owned Klass) -> () {
// CHECK: bb0([[ARG0:%.*]] : @owned $Klass, [[ARG1:%.*]] : @owned $(Klass, Klass), [[ARG2:%.*]] : @owned $Klass):
// CHECK:   ([[LHS:%.*]], [[RHS:%.*]]) = destructure_tuple [[ARG1]]
// CHECK:   [[TUP:%.*]] = tuple ([[LHS]] : $Klass, [[RHS]] : $Klass)
// CHECK:   [[STRUCT:%.*]] = struct $KlassWithKlassTuple ([[ARG0]] : $Klass, [[TUP]] : $(Klass, Klass), [[ARG2]] : $Klass)
// CHECK:   destroy_value [[STRUCT]]
// CHECK: } // end sil function 'multiple_inits_with_load_2'
sil [ossa] @multiple_inits_with_load_2 : $@convention(thin) (@owned Klass, @owned (Klass, Klass), @owned Klass) -> () {
bb0(%0 : @owned $Klass, %1 : @owned $(Klass, Klass), %2 : @owned $Klass):
  %stack = alloc_stack $KlassWithKlassTuple
  %stack0 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.first
  %stack1 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.second
  %stack2 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.third

  store %0 to [init] %stack0 : $*Klass
  store %1 to [init] %stack1 : $*(Klass, Klass)
  %c = copy_value %2 : $Klass
  store %c to [init] %stack2 : $*Klass

  %loaded = load [take] %stack2 : $*Klass
  destroy_value %loaded : $Klass

  store %2 to [init] %stack2 : $*Klass
  destroy_addr %stack : $*KlassWithKlassTuple
  dealloc_stack %stack : $*KlassWithKlassTuple
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @destroy_addr_not_fully_available : $@convention(thin) (@owned KlassWithKlassTuple) -> () {
// CHECK: bb0([[ARG0:%.*]] : @owned $KlassWithKlassTuple):
// CHECK-NOT: alloc_stack
// CHECK: destroy_value [[ARG0]]
// CHECK: } // end sil function 'destroy_addr_not_fully_available'
sil [ossa] @destroy_addr_not_fully_available : $@convention(thin) (@owned KlassWithKlassTuple) -> () {
bb0(%0 : @owned $KlassWithKlassTuple):
  %stack = alloc_stack $KlassWithKlassTuple
  store %0 to [init] %stack : $*KlassWithKlassTuple
  %stack0 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.first
  %stack1 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.second
  %stack2 = struct_element_addr %stack : $*KlassWithKlassTuple, #KlassWithKlassTuple.third

  destroy_addr %stack0 : $*Klass
  destroy_addr %stack1 : $*(Klass, Klass)
  destroy_addr %stack2 : $*Klass
  dealloc_stack %stack : $*KlassWithKlassTuple
  %9999 = tuple()
  return %9999 : $()
}

struct NativeObjectPair {
  var f1: Builtin.NativeObject
  var f2: Builtin.NativeObject
}

struct NativeObjectTriple {
  var f1: Builtin.NativeObject
  var f2: NativeObjectPair
}

sil @owned_user : $@convention(thin) (@owned Builtin.NativeObject) -> @owned Builtin.NativeObject
sil @owned_native_object_triple_user : $@convention(thin) (@owned NativeObjectTriple) -> @owned NativeObjectTriple

// diamond_test_4 from predictable_memopt.sil after running through
// predictable-memaccess-opt. We should be able to eliminate %2.
// CHECK-LABEL: sil [ossa] @diamond_test_4 : $@convention(thin) (@owned Builtin.NativeObject, @owned NativeObjectPair) -> () {
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'diamond_test_4'
sil [ossa] @diamond_test_4 : $@convention(thin) (@owned Builtin.NativeObject, @owned NativeObjectPair) -> () {
bb0(%0 : @owned $Builtin.NativeObject, %1 : @owned $NativeObjectPair):
  %2 = alloc_stack $NativeObjectTriple
  cond_br undef, bb1, bb2

bb1:
  %4 = struct_element_addr %2 : $*NativeObjectTriple, #NativeObjectTriple.f1
  %5 = struct_element_addr %2 : $*NativeObjectTriple, #NativeObjectTriple.f2
  store %0 to [init] %4 : $*Builtin.NativeObject
  store %1 to [init] %5 : $*NativeObjectPair
  br bb3

bb2:
  %13 = struct_element_addr %2 : $*NativeObjectTriple, #NativeObjectTriple.f1
  %14 = struct_element_addr %2 : $*NativeObjectTriple, #NativeObjectTriple.f2
  store %0 to [init] %13 : $*Builtin.NativeObject
  store %1 to [init] %14 : $*NativeObjectPair
  br bb3

bb3:
  destroy_addr %2 : $*NativeObjectTriple
  dealloc_stack %2 : $*NativeObjectTriple
  %9999 = tuple()
  return %9999 : $()
}

// We should do nothing here since we do not have a fully available value.
//
// CHECK-LABEL: sil [ossa] @promote_partial_store_assign : $@convention(thin) (@owned NativeObjectPair, @owned Builtin.NativeObject) -> () {
// CHECK: alloc_stack
// CHECK: } // end sil function 'promote_partial_store_assign'
sil [ossa] @promote_partial_store_assign : $@convention(thin) (@owned NativeObjectPair, @owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $NativeObjectPair, %1 : @owned $Builtin.NativeObject):
  %2 = alloc_stack $NativeObjectPair
  store %0 to [init] %2 : $*NativeObjectPair
  %3 = struct_element_addr %2 : $*NativeObjectPair, #NativeObjectPair.f1
  store %1 to [assign] %3 : $*Builtin.NativeObject
  destroy_addr %2 : $*NativeObjectPair
  dealloc_stack %2 : $*NativeObjectPair
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @load_take_opt_simple : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] : @owned $Builtin.NativeObject):
// CHECK-NOT: alloc_stack
// CHECK-NOT: load [take]
// CHECK:   [[RESULT:%.*]] = apply {{%.*}}([[ARG]])
// CHECK:   destroy_value [[RESULT]]
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'load_take_opt_simple'
sil [ossa] @load_take_opt_simple : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject):
  %1 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %1 : $*Builtin.NativeObject
  %0hat = load [take] %1 : $*Builtin.NativeObject
  %f = function_ref @owned_user : $@convention(thin) (@owned Builtin.NativeObject) -> @owned Builtin.NativeObject
  %0hathat = apply %f(%0hat) : $@convention(thin) (@owned Builtin.NativeObject) -> @owned Builtin.NativeObject
  store %0hathat to [init] %1 : $*Builtin.NativeObject
  destroy_addr %1 : $*Builtin.NativeObject
  dealloc_stack %1 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// We do not handle this today since we do not understand how to handle the
// destroy_value. We could teach the pass how to do this though.
//
// CHECK-LABEL: sil [ossa] @load_take_opt_simple_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] : @owned $Builtin.NativeObject):
// CHECK: alloc_box
// CHECK: } // end sil function 'load_take_opt_simple_box'
sil [ossa] @load_take_opt_simple_box : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject):
  %1 = alloc_box ${ var Builtin.NativeObject }
  %2 = project_box %1 : ${ var Builtin.NativeObject }, 0
  store %0 to [init] %2 : $*Builtin.NativeObject
  %0hat = load [take] %2 : $*Builtin.NativeObject
  %f = function_ref @owned_user : $@convention(thin) (@owned Builtin.NativeObject) -> @owned Builtin.NativeObject
  %0hathat = apply %f(%0hat) : $@convention(thin) (@owned Builtin.NativeObject) -> @owned Builtin.NativeObject
  store %0hathat to [init] %2 : $*Builtin.NativeObject
  destroy_value %1 : ${ var Builtin.NativeObject }
  %9999 = tuple()
  return %9999 : $()
}

// This test makes sure that we first eliminate the destroy_addr, before we
// eliminate the load [take] since the load [take] value is the available value
// of the destroy_addr.
//
// CHECK-LABEL: sil [ossa] @load_take_opt_identity : $@convention(thin) (@owned Builtin.NativeObject) -> () {
// CHECK: bb0([[ARG:%.*]] : @owned $Builtin.NativeObject):
// CHECK:   destroy_value [[ARG]]
// CHECK: } // end sil function 'load_take_opt_identity'
sil [ossa] @load_take_opt_identity : $@convention(thin) (@owned Builtin.NativeObject) -> () {
bb0(%0 : @owned $Builtin.NativeObject):
  %1 = alloc_stack $Builtin.NativeObject
  store %0 to [init] %1 : $*Builtin.NativeObject
  %0hat = load [take] %1 : $*Builtin.NativeObject
  store %0hat to [init] %1 : $*Builtin.NativeObject
  destroy_addr %1 : $*Builtin.NativeObject
  dealloc_stack %1 : $*Builtin.NativeObject
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @diamond_test_4_with_load_take : $@convention(thin) (@owned Builtin.NativeObject, @owned NativeObjectPair) -> () {
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'diamond_test_4_with_load_take'
sil [ossa] @diamond_test_4_with_load_take : $@convention(thin) (@owned Builtin.NativeObject, @owned NativeObjectPair) -> () {
bb0(%0 : @owned $Builtin.NativeObject, %1 : @owned $NativeObjectPair):
  %2 = alloc_stack $NativeObjectTriple
  cond_br undef, bb1, bb2

bb1:
  %4 = struct_element_addr %2 : $*NativeObjectTriple, #NativeObjectTriple.f1
  %5 = struct_element_addr %2 : $*NativeObjectTriple, #NativeObjectTriple.f2
  store %0 to [init] %4 : $*Builtin.NativeObject
  store %1 to [init] %5 : $*NativeObjectPair
  br bb3

bb2:
  %13 = struct_element_addr %2 : $*NativeObjectTriple, #NativeObjectTriple.f1
  %14 = struct_element_addr %2 : $*NativeObjectTriple, #NativeObjectTriple.f2
  store %0 to [init] %13 : $*Builtin.NativeObject
  store %1 to [init] %14 : $*NativeObjectPair
  br bb3

bb3:
  %f = function_ref @owned_native_object_triple_user : $@convention(thin) (@owned NativeObjectTriple) -> @owned NativeObjectTriple
  %loaded2 = load [take] %2 : $*NativeObjectTriple
  %fout = apply %f(%loaded2) : $@convention(thin) (@owned NativeObjectTriple) -> @owned NativeObjectTriple
  store %fout to [init] %2 : $*NativeObjectTriple
  destroy_addr %2 : $*NativeObjectTriple
  dealloc_stack %2 : $*NativeObjectTriple
  %9999 = tuple()
  return %9999 : $()
}

// Check dead-code elimination of alloc stack used only as inout parameter of a
// constant evaluable call (that only writes into that inout parameter).
sil [ossa] [_semantics "constant_evaluable"] @constevalFun : $@convention(thin) (@inout Builtin.Int32) -> () {
bb0(%0 : $*Builtin.Int32):
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @trivial_stack_with_consteval_calls : $@convention(thin) (Builtin.Int32) -> () {
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'trivial_stack_with_consteval_calls'
sil [ossa] @trivial_stack_with_consteval_calls : $@convention(thin) (Builtin.Int32) -> () {
bb0(%0 : $Builtin.Int32):
  %1 = alloc_stack $Builtin.Int32
  store %0 to [trivial] %1 : $*Builtin.Int32
  %4 = function_ref @constevalFun : $@convention(thin) (@inout Builtin.Int32) -> ()
  %5 = apply %4(%1) : $@convention(thin) (@inout Builtin.Int32) -> ()
  dealloc_stack %1 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

sil [ossa] [_semantics "constant_evaluable"] @constevalFun2 : $@convention(thin) (@in String, @inout Builtin.Int32) -> () {
bb0(%0 : $*String, %1 : $*Builtin.Int32):
  destroy_addr %0 : $*String
  %9999 = tuple()
  return %9999 : $()
}

// CHECK-LABEL: sil [ossa] @test_stack_elim_with_consteval_calls
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'test_stack_elim_with_consteval_calls'
sil [ossa] @test_stack_elim_with_consteval_calls : $@convention(thin) (@in String, Builtin.Int32) -> () {
bb0(%0 : $*String, %1 : $Builtin.Int32):
  %2 = alloc_stack $Builtin.Int32
  store %1 to [trivial] %2 : $*Builtin.Int32
  %4 = function_ref @constevalFun2 : $@convention(thin) (@in String, @inout Builtin.Int32) -> ()
  %5 = apply %4(%0, %2) : $@convention(thin) (@in String, @inout Builtin.Int32) -> ()
  dealloc_stack %2 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

sil [ossa] [_semantics "constant_evaluable"] @constevalFun3 : $@convention(thin) <A> (@in_guaranteed A) -> @out A {
bb0(%0 : $*A, %1 : $*A):
  copy_addr %1 to [initialization] %0 : $*A
  %4 = tuple ()
  return %4 : $()
}

// CHECK-LABEL: sil [ossa] @test_stack_elim_with_consteval_calls_with_indirect_results
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'test_stack_elim_with_consteval_calls_with_indirect_results'
sil [ossa] @test_stack_elim_with_consteval_calls_with_indirect_results : $@convention(thin) (@in_guaranteed Builtin.Int32) -> () {
bb0(%0 : $*Builtin.Int32):
  %3 = alloc_stack $Builtin.Int32
  %4 = function_ref @constevalFun3 : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> @out τ_0_0
  %5 = apply %4<Builtin.Int32>(%3, %0) : $@convention(thin) <τ_0_0> (@in_guaranteed τ_0_0) -> @out τ_0_0
  dealloc_stack %3 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

// This function cannot be dead-code eliminated as it has two indirectly writable arguments,
// and the analysis assumes that one memory location can escape through the other.
// TODO: This can fixed in the future but would require analyzing multiple alloc_stack
// locations together.
sil [ossa] [_semantics "constant_evaluable"] @constevalFun4 : $@convention(thin) <A> (@inout A) -> @out A {
bb0(%0 : $*A, %1 : $*A):
  copy_addr %1 to [initialization] %0 : $*A
  %4 = tuple ()
  return %4 : $()
}

// CHECK-LABEL: sil [ossa] @test_no_stack_elim_with_consteval_calls
// CHECK: alloc_stack
// CHECK: } // end sil function 'test_no_stack_elim_with_consteval_calls'
sil [ossa] @test_no_stack_elim_with_consteval_calls : $@convention(thin) (@inout Builtin.Int32) -> () {
bb0(%0 : $*Builtin.Int32):
  %3 = alloc_stack $Builtin.Int32
  %4 = function_ref @constevalFun4 : $@convention(thin) <τ_0_0> (@inout τ_0_0) -> @out τ_0_0
  %5 = apply %4<Builtin.Int32>(%3, %0) : $@convention(thin) <τ_0_0> (@inout τ_0_0) -> @out τ_0_0
  dealloc_stack %3 : $*Builtin.Int32
  %9999 = tuple()
  return %9999 : $()
}

// This is an example of dead alloc-stack elimination that is expected to
// happen with the OSLog APIs.

struct OSLogInterpolation {
  var formatString: String
}

enum Privacy {}

sil [_semantics "constant_evaluable"] @oslogInterpolationInit : $@convention(method) (@thin OSLogInterpolation.Type) -> @owned OSLogInterpolation

sil [_semantics "constant_evaluable"] @oslogAppendLiteral : $@convention(method) (@guaranteed String, @inout OSLogInterpolation) -> ()

sil [_semantics "constant_evaluable"] @oslogAppendInterpolation : $@convention(method) (@guaranteed @callee_guaranteed () -> Int, @in_guaranteed Privacy, @inout OSLogInterpolation) -> ()

sil [readonly] [_semantics "string.makeUTF8"] @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String

// CHECK-LABEL: sil [ossa] @test_dead_oslog_string_interpolation_alloc_stack_elimination
// CHECK-NOT: alloc_stack
// CHECK: } // end sil function 'test_dead_oslog_string_interpolation_alloc_stack_elimination'
sil [ossa] @test_dead_oslog_string_interpolation_alloc_stack_elimination : $@convention(thin) (@guaranteed @callee_guaranteed () -> Int, @in_guaranteed Privacy) -> () {
bb0(%0 : @guaranteed $@callee_guaranteed () -> Int, %1: $*Privacy):
  %2 = alloc_stack $OSLogInterpolation, var, name "$interpolation"
  %9 = metatype $@thin OSLogInterpolation.Type
  %10 = function_ref @oslogInterpolationInit : $@convention(method) (@thin OSLogInterpolation.Type) -> @owned OSLogInterpolation
  %11 = apply %10(%9) : $@convention(method) (@thin OSLogInterpolation.Type) -> @owned OSLogInterpolation
  store %11 to [init] %2 : $*OSLogInterpolation
  %13 = string_literal utf8 "Minimum integer value: "
  %14 = integer_literal $Builtin.Word, 23
  %15 = integer_literal $Builtin.Int1, -1
  %16 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %17 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %18 = apply %17(%13, %14, %15, %16) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String
  %19 = begin_access [modify] [static] %2 : $*OSLogInterpolation
  %20 = function_ref @oslogAppendLiteral : $@convention(method) (@guaranteed String, @inout OSLogInterpolation) -> ()
  %21 = apply %20(%18, %19) : $@convention(method) (@guaranteed String, @inout OSLogInterpolation) -> ()
  end_access %19 : $*OSLogInterpolation
  destroy_value %18 : $String
  %29 = begin_access [modify] [static] %2 : $*OSLogInterpolation
  %33 = function_ref @oslogAppendInterpolation : $@convention(method) (@guaranteed @callee_guaranteed () -> Int, @in_guaranteed Privacy, @inout OSLogInterpolation) -> ()
  %34 = apply %33(%0, %1, %29) : $@convention(method) (@guaranteed @callee_guaranteed () -> Int, @in_guaranteed Privacy, @inout OSLogInterpolation) -> ()
  end_access %29 : $*OSLogInterpolation
  %41 = string_literal utf8 ""
  %42 = integer_literal $Builtin.Word, 0
  %43 = integer_literal $Builtin.Int1, -1
  %44 = metatype $@thin String.Type
  // function_ref String.init(_builtinStringLiteral:utf8CodeUnitCount:isASCII:)
  %45 = function_ref @$sSS21_builtinStringLiteral17utf8CodeUnitCount7isASCIISSBp_BwBi1_tcfC : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String // user: %46
  %46 = apply %45(%41, %42, %43, %44) : $@convention(method) (Builtin.RawPointer, Builtin.Word, Builtin.Int1, @thin String.Type) -> @owned String // users: %51, %49
  %47 = begin_access [modify] [static] %2 : $*OSLogInterpolation
  %48 = function_ref @oslogAppendLiteral : $@convention(method) (@guaranteed String, @inout OSLogInterpolation) -> ()
  %49 = apply %48(%46, %47) : $@convention(method) (@guaranteed String, @inout OSLogInterpolation) -> ()
  end_access %47 : $*OSLogInterpolation
  destroy_value %46 : $String
  destroy_addr %2 : $*OSLogInterpolation
  dealloc_stack %2 : $*OSLogInterpolation
  %9999 = tuple()
  return %9999 : $()
}
