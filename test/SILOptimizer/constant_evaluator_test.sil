// RUN: %target-sil-opt -test-constant-evaluator %s 2>&1 | %FileCheck %s

/// Tests for the constant evaluator in stepwise evaluation mode (also referred
/// to as flow-sensitive mode) in which instructions are evaluated following
/// the control flow of the program. The evaluator will be run on every function
/// whose name starts with `interpret` prefix and outputs the constant value
/// returned by the function or diagnostics if the evaluation fails.

sil_stage canonical

import Builtin
import Swift

// Test builtin literals and operations.

// CHECK-LABEL: @interpretBuiltinIntLiteral
sil @interpretBuiltinIntLiteral : $@convention(thin) () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 17
  return %0 : $(Builtin.Int64)
} // CHECK: Returns int: 17

// CHECK-LABEL: @interpretBuiltinAddition
sil @interpretBuiltinAddition : $@convention(thin) () -> Builtin.Int32 {
bb0:
  %0 = integer_literal $Builtin.Int32, 1
  %1 = builtin "add_Int32"(%0 : $Builtin.Int32, %0 : $Builtin.Int32) : $(Builtin.Int32)
  return %1 : $(Builtin.Int32)
} // CHECK: Returns int: 2

// CHECK-LABEL: @interpretBuiltinAddWrapAround
sil @interpretBuiltinAddWrapAround : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.Int8, 127
  %1 = integer_literal $Builtin.Int8, 1
  %2 = builtin "add_Int32"(%0 : $Builtin.Int8, %1 : $Builtin.Int8) : $(Builtin.Int8)
  return %2 : $(Builtin.Int8)
} // CHECK: Returns int: -128

// CHECK-LABEL: @interpretBuiltinMultiplication
sil @interpretBuiltinMultiplication : $@convention(thin) () -> Builtin.Int64 {
bb0:
%0 = integer_literal $Builtin.Int64, 10
%1 = integer_literal $Builtin.Int64, 11
%2 = builtin "mul_Int64"(%0 : $Builtin.Int64, %1 : $Builtin.Int64) : $(Builtin.Int64)
return %2 : $(Builtin.Int64)
} // CHECK: Returns int: 110

// CHECK-LABEL: @interpretBuiltinDivision
sil @interpretBuiltinDivision : $@convention(thin) () -> Builtin.Int16 {
bb0:
  %0 = integer_literal $Builtin.Int16, 10
  %1 = integer_literal $Builtin.Int16, 11
  %2 = builtin "sdiv_Int16"(%1 : $Builtin.Int16, %0 : $Builtin.Int16) : $(Builtin.Int16)
  return %2 : $(Builtin.Int16)
} // CHECK: Returns int: 1

// CHECK-LABEL: @interpretBuiltinModulo
sil @interpretBuiltinModulo : $@convention(thin) () -> Builtin.Int16 {
bb0:
  %0 = integer_literal $Builtin.Int16, 23
  %1 = integer_literal $Builtin.Int16, 6
  %2 = builtin "srem_Int16"(%0 : $Builtin.Int16, %1 : $Builtin.Int16) : $(Builtin.Int16)
  return %2 : $(Builtin.Int16)
} // CHECK: Returns int: 5

// CHECK-LABEL: @interpretBuiltinLeftShift
sil @interpretBuiltinLeftShift : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.Int8, 10
  %1 = integer_literal $Builtin.Int8, 2
  %2 = builtin "shl_Int8"(%0 : $Builtin.Int8, %1: $Builtin.Int8) : $(Builtin.Int8)
  return %2 : $(Builtin.Int8)
} // CHECK: Returns int: 40

// CHECK-LABEL: @interpretBuiltinRightShift
sil @interpretBuiltinRightShift : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.Int8, 10
  %1 = integer_literal $Builtin.Int8, 2
  %2 = builtin "ashr_Int8"(%0 : $Builtin.Int8, %1: $Builtin.Int8) : $(Builtin.Int8)
  return %2 : $(Builtin.Int8)
} // CHECK: Returns int: 2

// CHECK-LABEL: @interpretBuiltinBitWiseAnd
sil @interpretBuiltinBitWiseAnd : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.Int8, 10
  %1 = integer_literal $Builtin.Int8, 8
  %2 = builtin "and_Int8"(%0 : $Builtin.Int8, %1: $Builtin.Int8) : $(Builtin.Int8)
  return %2 : $(Builtin.Int8)
} // CHECK: Returns int: 8

// CHECK-LABEL: @interpretBuiltinBitWiseOr
sil @interpretBuiltinBitWiseOr : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.Int8, 10
  %1 = integer_literal $Builtin.Int8, 8
  %2 = builtin "or_Int8"(%0 : $Builtin.Int8, %1: $Builtin.Int8) : $(Builtin.Int8)
  return %2 : $(Builtin.Int8)
} // CHECK: Returns int: 10

// Test conditional branches and comparison operators.

// CHECK-LABEL: @interpretFalseBranch
sil hidden @interpretFalseBranch : $@convention(thin) () -> Builtin.Int64 {
bb0:
  %1 = integer_literal $Builtin.Int64, 100
  %2 = integer_literal $Builtin.Int64, 0
  %3 = builtin "cmp_slt_Int64"(%1 : $Builtin.Int64, %2 : $Builtin.Int64) : $Builtin.Int1
  cond_br %3, bb1, bb2

bb1:
  %8 = integer_literal $Builtin.Int64, 0
  br bb3(%8 : $Builtin.Int64)

bb2:
  br bb3(%1 : $Builtin.Int64)

bb3(%12 : $Builtin.Int64):
  return %12 : $Builtin.Int64
} // CHECK: Returns int: 100

// CHECK-LABEL: @interpretTrueBranch
sil hidden @interpretTrueBranch : $@convention(thin) () -> Builtin.Int64 {
bb0:
  %1 = integer_literal $Builtin.Int64, 100
  %2 = integer_literal $Builtin.Int64, 0
  %3 = builtin "cmp_slt_Int64"(%1 : $Builtin.Int64, %2 : $Builtin.Int64) : $Builtin.Int1
  %4 = integer_literal $Builtin.Int1, -1
  %5 = builtin "xor_Int1"(%3 : $Builtin.Int1, %4 : $Builtin.Int1) : $Builtin.Int1
  cond_br %5, bb1, bb2

bb1:
  %8 = integer_literal $Builtin.Int64, 0
  br bb3(%8 : $Builtin.Int64)

bb2:
  br bb3(%1 : $Builtin.Int64)

bb3(%12 : $Builtin.Int64):
  return %12 : $Builtin.Int64
} // CHECK: Returns int: 0

// Test builtin truncation and extension.

// CHECK-LABEL: @interpretSignedTruncation
sil @interpretSignedTruncation : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.Int64, -1
  %1 = builtin "s_to_s_checked_trunc_Int64_Int8"(%0 : $Builtin.Int64) : $(Builtin.Int8, Builtin.Int1)
  %2 = tuple_extract %1 : $(Builtin.Int8, Builtin.Int1), 0
  return %2 : $(Builtin.Int8)
} // CHECK: Returns int: -1

// CHECK-LABEL: @interpretSignedExtend
sil @interpretSignedExtend : $@convention(thin) () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int8, -1
  %1 = builtin "sext_Int8_Int64"(%0 : $Builtin.Int8) : $Builtin.Int64
  return %1 : $(Builtin.Int64)
} // CHECK: Returns int: -1

// CHECK-LABEL: @interpretZeroExtend
sil @interpretZeroExtend : $@convention(thin) () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int8, -1
  %1 = builtin "zext_Int8_Int64"(%0 : $Builtin.Int8) : $Builtin.Int64
  return %1 : $(Builtin.Int64)
} // CHECK: Returns int: 255

// FIXME: assertion failure in conversion of s_to_s_checked_trunc_IntLiteral.
sil @xfailInterpretBuiltinIntLiteralTrunc : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.IntLiteral, 2
  %2 = builtin "s_to_s_checked_trunc_IntLiteral_Int8"(%0 : $Builtin.IntLiteral) : $(Builtin.Int8, Builtin.Int1)
  %3 = tuple_extract %2 : $(Builtin.Int8, Builtin.Int1), 0
  return %3 : $(Builtin.Int8)
}

// Test overflow diagnostics.
// FIXME: Imprecision:  the following builtin operations return a tuple where
// the second element indicate whether an overflow happened or not.
// The interpreter currently makes the entire tuple unknown in the case of
// overflow. This should be replaced by the correct semantics of the builtin
// which produces a trucated value for the first element and returns true for
// the second element.

// CHECK-LABEL: @interpretSignedTruncationError
sil @interpretSignedTruncationError : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.Int64, -1
  %1 = builtin "s_to_u_checked_trunc_Int64_Int8"(%0 : $Builtin.Int64) : $(Builtin.Int8, Builtin.Int1)
    // CHECK: {{.*}}:[[@LINE-1]]:{{.*}}: note: integer overflow detected
  %2 = tuple_extract %1 : $(Builtin.Int8, Builtin.Int1), 0
  return %2 : $(Builtin.Int8)
}

// CHECK-LABEL: @interpretBuiltinAddOverflow
sil @interpretBuiltinAddOverflow : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.Int8, 127
  %1 = integer_literal $Builtin.Int8, 1
  %2 = integer_literal $Builtin.Int1, -1
  %3 = builtin "sadd_with_overflow_Int8"(%0 : $Builtin.Int8, %1 : $Builtin.Int8, %2: $Builtin.Int1) : $(Builtin.Int8, Builtin.Int1)
    // CHECK: {{.*}}:[[@LINE-1]]:{{.*}}: note: integer overflow detected
  %4 = tuple_extract %3 : $(Builtin.Int8, Builtin.Int1), 0
  return %4 : $(Builtin.Int8)
}

// Test function calls

sil hidden @identity : $@convention(thin) (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  return %0 : $Builtin.Int64
}

// CHECK-LABEL: @interpretCallTest
sil hidden @interpretCallTest : $@convention(thin) () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 10
  %2 = function_ref @identity : $@convention(thin) (Builtin.Int64) -> Builtin.Int64
  %3 = apply %2(%0) : $@convention(thin) (Builtin.Int64) -> Builtin.Int64
  return %3 : $Builtin.Int64
} // CHECK: Returns int: 10

// A function that computes factorial of a Builtin.Int64 and traps on overflow.
sil hidden @factorial : $@convention(thin) (Builtin.Int64) -> Builtin.Int64 {
bb0(%0 : $Builtin.Int64):
  %2 = integer_literal $Builtin.Int64, 0
  %4 = builtin "cmp_eq_Int64"(%0 : $Builtin.Int64, %2 : $Builtin.Int64) : $Builtin.Int1
  cond_br %4, bb1, bb2

bb1:
  %8 = integer_literal $Builtin.Int64, 1
  br bb3(%8 : $Builtin.Int64)

bb2:
  %11 = integer_literal $Builtin.Int64, 1
  %13 = integer_literal $Builtin.Int1, -1
  %14 = builtin "usub_with_overflow_Int64"(%0 : $Builtin.Int64, %11 : $Builtin.Int64, %13 : $Builtin.Int1) : $(Builtin.Int64, Builtin.Int1)
  %15 = tuple_extract %14 : $(Builtin.Int64, Builtin.Int1), 0
  %16 = tuple_extract %14 : $(Builtin.Int64, Builtin.Int1), 1
  cond_fail %16 : $Builtin.Int1
  %19 = function_ref @factorial : $@convention(thin) (Builtin.Int64) -> Builtin.Int64
  %20 = apply %19(%15) : $@convention(thin) (Builtin.Int64) -> Builtin.Int64
  %23 = integer_literal $Builtin.Int1, -1
  %24 = builtin "umul_with_overflow_Int64"(%0 : $Builtin.Int64, %20 : $Builtin.Int64, %23 : $Builtin.Int1) : $(Builtin.Int64, Builtin.Int1)
  %25 = tuple_extract %24 : $(Builtin.Int64, Builtin.Int1), 0
  %26 = tuple_extract %24 : $(Builtin.Int64, Builtin.Int1), 1
  cond_fail %26 : $Builtin.Int1
  br bb3(%25 : $Builtin.Int64)

bb3(%30 : $Builtin.Int64):
  return %30 : $Builtin.Int64
}

// CHECK-LABEL: @interpretFactorialCall
sil hidden @interpretFactorialCall : $@convention(thin) () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 5
  %2 = function_ref @factorial : $@convention(thin) (Builtin.Int64) -> Builtin.Int64
  %3 = apply %2(%0) : $@convention(thin) (Builtin.Int64) -> Builtin.Int64
  return %3 : $Builtin.Int64
} // CHECK: Returns int: 120

// CHECK-LABEL: @interpretAndDignoseLongRecursion
sil hidden @interpretAndDignoseLongRecursion : $@convention(thin) () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, -5
  %2 = function_ref @factorial : $@convention(thin) (Builtin.Int64) -> Builtin.Int64
  %3 = apply %2(%0) : $@convention(thin) (Builtin.Int64) -> Builtin.Int64
    // CHECK: {{.*}}:[[@LINE-1]]:{{.*}}: note: exceeded instruction limit: 512 when evaluating the expression at compile time
    // CHECK: {{.*}}: note: limit exceeded here
  return %3 : $Builtin.Int64
}

// Test meta types.

// CHECK-LABEL: @interpretIntMetatype
sil @interpretIntMetatype : $@convention(thin) () -> @thin Int.Type {
bb0:
  %0 = metatype $@thin Int.Type
  return %0 : $@thin Int.Type
} // CHECK: Returns metatype: Int

// CHECK-LABEL: @interpretStringMetatype
sil @interpretStringMetatype : $@convention(thin) () -> @thin String.Type {
bb0:
  %0 = metatype $@thin String.Type
  return %0 : $@thin String.Type
} // CHECK: Returns metatype: String

// Test standard integers.

// CHECK-LABEL: @interpretIntInit
sil @interpretIntInit : $@convention(thin) () -> Builtin.Int64 {
bb0:
  %0 = integer_literal $Builtin.Int64, 122
  %1 = struct $Int64 (%0 : $Builtin.Int64)
  %2 = struct_extract %1 : $Int64, #Int64._value
  return %2 : $Builtin.Int64
} // CHECK: Returns int: 122

sil @mockInt8Init : $@convention(thin) (Builtin.Int64, @thin Int8.Type) -> Int8 {
bb0(%0 : $Builtin.Int64, %1 : $@thin Int8.Type):
  %2 = builtin "s_to_s_checked_trunc_Int64_Int8"(%0 : $Builtin.Int64) : $(Builtin.Int8, Builtin.Int1)
  %3 = tuple_extract %2 : $(Builtin.Int8, Builtin.Int1), 0
  %4 = struct $Int8 (%3 : $Builtin.Int8)
  return %4 : $Int8
}

// CHECK-LABEL: @interpretInt8Init
sil @interpretInt8Init : $@convention(thin) () -> Builtin.Int8 {
bb0:
  %0 = integer_literal $Builtin.Int64, 122
  %1 = metatype $@thin Int8.Type
  %2 = function_ref @mockInt8Init : $@convention(thin) (Builtin.Int64, @thin Int8.Type) -> Int8
  %3 = apply %2(%0, %1) : $@convention(thin) (Builtin.Int64, @thin Int8.Type) -> Int8
  %4 = struct_extract %3 : $Int8, #Int8._value
  return %4 : $Builtin.Int8
} // CHECK: Returns int: 122

sil @boolEquals : $@convention(method) (Bool, Bool, @thin Bool.Type) -> Bool {
bb0(%0 : $Bool, %1 : $Bool, %2 : $@thin Bool.Type):
  %3 = struct_extract %0 : $Bool, #Bool._value
  %4 = struct_extract %1 : $Bool, #Bool._value
  %5 = builtin "cmp_eq_Int1"(%3 : $Builtin.Int1, %4 : $Builtin.Int1) : $Builtin.Int1
  %6 = struct $Bool (%5 : $Builtin.Int1)
  return %6 : $Bool
}

// CHECK-LABEL: @interpretBoolEquals
sil @interpretBoolEquals : $@convention(thin) () -> Builtin.Int1 {
bb0:
  %0 = integer_literal $Builtin.Int1, 0
  %1 = struct $Bool (%0 : $Builtin.Int1)
  %2 = integer_literal $Builtin.Int1, -1
  %3 = struct $Bool (%2 : $Builtin.Int1)
  %4 = metatype $@thin Bool.Type
  %5 = function_ref @boolEquals : $@convention(method) (Bool, Bool, @thin Bool.Type) -> Bool
  %6 = apply %5(%1, %3, %4) : $@convention(method) (Bool, Bool, @thin Bool.Type) -> Bool
  %7 = struct_extract %6 : $Bool, #Bool._value
  return %7 : $Builtin.Int1
} // CHECK: Returns int: 0

// Test custom structs.

// Test structs with mutation.

// Test non-constant diagnostics.

// CHECK-LABEL: @interpretAndDiagnoseNonConstantVars
sil hidden @interpretAndDiagnoseNonConstantVars : $@convention(thin) (Int) -> () {
bb0(%0 : $Int):
  %4 = struct_extract %0 : $Int, #Int._value
    // CHECK: {{.*}}:[[@LINE-1]]:{{.*}}: note: expression not evaluable as constant here
  %10 = tuple ()
  return %10 : $()
}

sil @$ss8readLine16strippingNewlineSSSgSb_tF : $@convention(thin) (Bool) -> @owned Optional<String>

// CHECK-LABEL: @interpretAndDiagnoseNonConstantCalls
sil @interpretAndDiagnoseNonConstantCalls : $@convention(thin) () -> () {
bb0:
  %0 = integer_literal $Builtin.Int1, -1
  %1 = struct $Bool (%0 : $Builtin.Int1)
  // function_ref readLine(strippingNewline:)
  %2 = function_ref @$ss8readLine16strippingNewlineSSSgSb_tF : $@convention(thin) (Bool) -> @owned Optional<String>
  %3 = apply %2(%1) : $@convention(thin) (Bool) -> @owned Optional<String>
    // CHECK: {{.*}}:[[@LINE-1]]:{{.*}}: note: expression not evaluable as constant here
  release_value %3 : $Optional<String>
  %5 = tuple ()
  return %5 : $()
}

// Test loop diagnostics.

// CHECK-LABEL: @interpretAndDiagnoseLoops
sil hidden @interpretAndDiagnoseLoops : $@convention(thin) () -> () {
bb0:
  br bb1

bb1:
  %3 = integer_literal $Builtin.Int64, 0
  %4 = integer_literal $Builtin.Int64, 100

  %5 = builtin "cmp_slt_Int64"(%3 : $Builtin.Int64, %4 : $Builtin.Int64) : $Builtin.Int1
  cond_br %5, bb2, bb3

bb2:
  br bb1
    // CHECK: {{.*}}:[[@LINE-1]]:{{.*}}: note: control-flow loop found during evaluation 

bb3:
  %10 = tuple ()
  return %10 : $()
}

// Test strings.

// Test enums and optionals.

// TODO: add tests for generics.
